<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../amf-helper-mixin/amf-helper-mixin.html">
<script>
/**
 * `api-example-generator`
 *
 * Examples generator from AMF model
 *
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin ApiElements.AmfHelperMixin
 */
class ApiExampleGenerator extends ApiElements.AmfHelperMixin(Polymer.Element) {
  /**
   * @type {String}
   */
  static get is() {
    return 'api-example-generator';
  }
  /**
   * @type {Object}
   */
  static get properties() {
    return {
      /**
       * AMF `http://a.ml/vocabularies/http#Payload` shape type.
       * Note, you must set `amfModel` property to resolve references in
       * the model.
       * @type {Object}
       */
      shape: Object,
      /**
       * Auto generated example.
       */
      example: {
        type: String,
        readOnly: true,
        notify: true
      },
      /**
       * When set it automatically generates the example when shape value change
       */
      auto: Boolean
    };
  }
  /**
   * @type {Array}
   */
  static get observers() {
    return [
      '_shapeAutoChanged(shape, auto)'
    ];
  }
  /**
   * Generates example when shape changes when `auto` is set to true.
   *
   * @param {Array|Object} shape
   * @param {?Boolean} auto
   */
  _shapeAutoChanged(shape, auto) {
    if (!auto) {
      return;
    }
    if (!shape) {
      this._setExample(undefined);
      return;
    }
    const example = this.generate(shape);
    this._setExample(example);
  }

  /**
   * Generates the example from a shape.
   * @param {?Array|Object} shape AMF shape definition
   * @param {?Object} opts Generation options:
   * - type `String` - Type name of an union type. If not set it uses first type
   * in the union.
   * @return {String|undefined} Example value.
   */
  generate(shape, opts) {
    if (!shape) {
      shape = this.shape;
    }
    if (!shape) {
      return;
    }
    if (shape instanceof Array) {
      shape = shape[0];
    }
    shape = this._resolve(shape);
    const mediaType = this._getValue(shape,
      this.ns.raml.vocabularies.http + 'mediaType');
    if (!mediaType) {
      return;
    }
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.http + 'schema');
    let schema = shape[sKey];
    if (!schema) {
      return;
    }
    if (schema instanceof Array) {
      schema = schema[0];
    }
    return this.computeExample(mediaType, schema, opts);
  }
  /**
   * Computes an example for given media type.
   * @param {String} type Media type
   * @param {Object} schema Payload's schema
   * @param {?Object} opts Generation options:
   * - type `String` - Type name of an union type. If not set it uses first type
   * in the union.
   * @return {String|undefined}
   */
  computeExample(type, schema, opts) {
    if (this._hasType(schema,
      this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      const iKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
      const items = this._ensureArray(schema[iKey]);
      // We need only first type here as arras can have different types
      for (let i = 0, len = items.length; i < len; i++) {
        const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
        const properties = this._ensureArray(items[i][pKey]);
        if (!properties) {
          if (this._hasType(items[i], this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
            const example = this._computeScalarType(items[i]);
            if (example) {
              return '["' + example + '"]';
            }
          }
          continue;
        }
        const typeName = this._getValue(items[i], this.ns.w3.shacl.name + 'name');
        const _example = this._exampleFromProperties(type, properties, typeName);
        if (_example) {
          return '[' + _example + ']';
        }
      }
      return;
    }
    if (this._hasType(schema, this.ns.raml.vocabularies.document + 'Example')) {
      return this._exampleFromExamples(type, [schema]);
    }
    if (this._hasType(schema, this.ns.raml.vocabularies.shapes + 'UnionShape')) {
      if (!opts) {
        opts = {};
      }
      const unionShape = this._getUnionShape(schema, opts);
      if (!unionShape) {
        return;
      }
      return this.computeExample(type, unionShape, opts);
    }

    const eKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
    const examples = this._ensureArray(schema[eKey]);
    if (examples && examples.length) {
      const result = this._exampleFromExamples(type, examples);
      if (result) {
        return result;
      }
    }
    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    const properties = this._ensureArray(schema[pKey]);
    if (properties && properties.length) {
      const typeName = this._getValue(schema, this.ns.w3.shacl.name + 'name');
      return this._exampleFromProperties(type, properties, typeName);
    }
  }
  /**
   * Computes value from defined `datatype` property.
   * @param {Object} shape A shape with `datatype` property.
   * @return {String|undefined} Value of the data type.
   */
  _computeScalarType(shape) {
    const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
    let dt = shape[dtKey];
    if (!dt) {
      return;
    }
    if (dt instanceof Array) {
      dt = dt[0];
    }
    let id = dt['@id'] ? dt['@id'] : dt;
    const w3index = id.indexOf(this.ns.w3.xmlSchema);
    if (w3index !== -1) {
      id = id.substr(this.ns.w3.xmlSchema.length);
    }
    const shapeindex = id.indexOf(this.ns.raml.vocabularies.shapes);
    if (shapeindex !== -1) {
      id = id.substr(this.ns.raml.vocabularies.shapes.length);
    }
    const index = id.indexOf(':');
    if (index !== -1) {
      id = id.substr(index);
    }
    return id[0].toUpperCase() + id.substr(1);
  }
  /**
   * Gets a shape for union type
   * @param {Object} schema Union's model
   * @param {?Object} opts See `computeExample()` for description
   * @return {Object|undefined} Model for shape or un defined if not found
   */
  _getUnionShape(schema, opts) {
    if (!schema) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
    let anyOf = schema[key];
    if (!anyOf) {
      return;
    }
    if (!(anyOf instanceof Array)) {
      anyOf = [anyOf];
    }
    if (!opts.type) {
      let item = anyOf[0];
      if (item instanceof Array) {
        item = item[0];
      }
      return this._resolve(item);
    }
    for (let i = 0, len = anyOf.length; i < len; i++) {
      let item = anyOf[i];
      if (item instanceof Array) {
        item = item[0];
      }
      item = this._resolve(item);
      const name = this._getValue(item, this.ns.w3.shacl.name + 'name');
      if (name === opts.type) {
        return item;
      }
    }
  }
  /**
   * Searches for an example in examples array by it's media type.
   * @param {String} type Payload's media type
   * @param {Array<Object>} examples List of examples
   * @return {Object|undefined} Example's model or undefined if not found.
   */
  _exampleFromMediaType(type, examples) {
    let example;
    for (let i = 0; i < examples.length; i++) {
      const _tmp = examples[i];
      const _type = this._getValue(_tmp,
        this.ns.raml.vocabularies.http + 'mediaType');
      if (type !== _type) {
        continue;
      }
      example = _tmp;
      break;
    }
    return example;
  }
  /**
   * Generate an example from the examples array.
   *
   * @param {String} type Bosy content type.
   * @param {Array<Object>} examples Resolved examples.
   * @return {String|undefined}
   */
  _exampleFromExamples(type, examples) {
    const example = examples.length === 1 ? examples[0] :
      this._exampleFromMediaType(type, examples);
    if (!example) {
      return;
    }
    let raw = this._getValue(example,
      this.ns.raml.vocabularies.document + 'raw');
    if (!raw) {
      raw = this._getValue(example, this.ns.w3.shacl.name + 'raw');
    }
    if (raw) {
      if (type.indexOf('json') === -1) {
        return raw;
      }
      try {
        JSON.parse(raw);
        return raw;
      } catch (_) {}
    }
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'structuredValue');
    let structure = example[sKey];
    if (!structure) {
      return;
    }
    if (structure instanceof Array) {
      structure = structure[0];
    }
    const result = this._jsonFromStructure(structure);
    if (result) {
      if (typeof result === 'object') {
        return JSON.stringify(result, null, 2);
      }
    }
  }
  /**
   * Creates a JSON example representation from AMF example's structure
   * definition.
   * @param {Object} structure
   * @return {any}
   */
  _jsonFromStructure(structure) {
    if (!structure) {
      return;
    }
    const prefix = this.ns.raml.vocabularies.data;
    if (this._hasType(structure, prefix + 'Scalar')) {
      const key = this._getAmfKey(prefix + 'value');
      return this._getTypedValue(structure[key]);
    }
    let obj;
    let isArray = false;
    if (this._hasType(structure, prefix + 'Object')) {
      obj = {};
    } else if (this._hasType(structure, prefix + 'Array')) {
      obj = [];
      isArray = true;
    } else {
      return;
    }
    if (isArray && this._hasProperty(structure, this.ns.w3.name + '1999/02/22-rdf-syntax-ns#member')) {
      const key = this._getAmfKey(this.ns.w3.name + '1999/02/22-rdf-syntax-ns#member');
      const items = structure[key];
      for (let i = 0, len = items.length; i < len; i++) {
        const item = items[i];
        this._jsonFromStructureValue(item, obj, isArray);
      }
    } else {
      const resolvedPrefix = this._getAmfKey(prefix);
      Object.keys(structure).forEach((key) => {
        if (key.indexOf(resolvedPrefix) !== 0) {
          return;
        }
        let v = structure[key];
        this._jsonFromStructureValue(v, obj, isArray, key, resolvedPrefix);
      });
    }
    return obj;
  }

  _jsonFromStructureValue(value, obj, isArray, key, resolvedPrefix) {
    if (value instanceof Array) {
      value = value[0];
    }
    const tmp = this._jsonFromStructure(value);
    if (!tmp) {
      return;
    }
    if (isArray) {
      obj[obj.length] = tmp;
    } else {
      key = key.replace(resolvedPrefix, '');
      if (key[0] === ':') {
        key = key.substr(1);
      }
      obj[key] = tmp;
    }
  }

  _getTypedValue(shape) {
    if (!shape) {
      return;
    }
    if (shape instanceof Array) {
      shape = shape[0];
    }
    let value = shape['@value'];
    if (!value) {
      return value;
    }

    let dt = shape['@type'];
    if (!dt) {
      return value || '';
    }
    if (dt instanceof Array) {
      dt = dt[0];
    }
    let prefix = this._getAmfKey(this.ns.w3.xmlSchema);
    if (prefix !== this.ns.w3.xmlSchema) {
      prefix += ':';
    }
    switch (dt) {
      case prefix + 'boolean':
      case this.ns.w3.xmlSchema + 'boolean':
        if (value !== undefined) {
          return value === 'true' ? true : false;
        }
        return value;
      case prefix + 'integer':
      case this.ns.w3.xmlSchema + 'integer':
      case prefix + 'number':
      case this.ns.w3.xmlSchema + 'number':
        if (value) {
          if (isNaN(value)) {
            return 0;
          }
          return Number(value);
        }
        return 0;
      default: return value || '';
    }
  }
  /**
   * Creates an example from RAML type properties.
   * @param {String} type Media type
   * @param {Array} properties
   * @param {?String} typeName Name of the RAML type.
   * @return {any}
   */
  _exampleFromProperties(type, properties, typeName) {
    if (type.indexOf('json') !== -1) {
      const value = this._jsonExampleFromProperties(properties);
      if (value) {
        return JSON.stringify(value, null, 2);
      }
      return;
    }
    if (type.indexOf('xml') !== -1) {
      return this._xmlExampleFromProperties(properties, typeName);
    }
  }
  /**
   * Generates a JSON example from RAML's type properties.
   * @param {Array} properties List of type properties
   * @return {String|undefined}
   */
  _jsonExampleFromProperties(properties) {
    const result = {};
    for (let i = 0, len = properties.length; i < len; i++) {
      const property = properties[i];
      const name = this._getValue(property, this.ns.w3.shacl.name + 'name');
      if (!name) {
        continue;
      }
      const rKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'range');
      let range = property[rKey];
      if (!range) {
        continue;
      }
      if (range instanceof Array) {
        range = range[0];
      }
      const value = this._computeJsonProperyValue(range);
      result[name] = value || '';
    }
    return result;
  }
  /**
   * Computes JSON value from a range shape.
   * @param {Object} range AMF's range model.
   * @return {any}
   */
  _computeJsonProperyValue(range) {
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
      return this._computeJsonScalarValue(range);
    }
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'UnionShape')) {
      return this._computeJsonUnionValue(range);
    }
    if (this._hasType(range, this.ns.w3.shacl.name + 'NodeShape')) {
      return this._computeJsonObjectValue(range);
    }
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      return this._computeJsonArrayValue(range);
    }
  }
  _computeJsonScalarValue(range) {
    let value = this._getTypeScalarValue(range);
    if (!value) {
      return '';
    }
    let prefix = this._getAmfKey(this.ns.w3.xmlSchema);
    if (prefix !== this.ns.w3.xmlSchema) {
      prefix += ':';
    }
    const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
    let dt = range[dtKey];
    if (!dt) {
      return value || '';
    }
    if (dt instanceof Array) {
      dt = dt[0];
    }
    switch (dt['@id']) {
      case prefix + 'boolean':
      case this.ns.w3.xmlSchema + 'boolean':
        if (value !== undefined) {
          return value === 'true' ? true : false;
        }
        return value;
      case prefix + 'integer':
      case this.ns.w3.xmlSchema + 'integer':
      case prefix + 'number':
      case this.ns.w3.xmlSchema + 'number':
        if (value) {
          if (isNaN(value)) {
            return 0;
          }
          return Number(value);
        }
        return 0;
      default: return value || '';
    }
  }

  _computeJsonUnionValue(range) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
    const list = this._ensureArray(range[key]);
    if (!list) {
      return;
    }
    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    for (let i = 0, len = list.length; i < len; i++) {
      let item = list[i];
      if (item instanceof Array) {
        item = item[0];
      }
      if (this._hasType(item, this.ns.w3.shacl.name + 'NodeShape')) {
        item = this._resolve(item);
        const data = this._ensureArray(item[pKey]);
        if (data) {
          return this._jsonExampleFromProperties(data);
        }
      }
    }
  }

  _computeJsonObjectValue(range) {
    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    const properties = this._ensureArray(range[pKey]);
    if (properties && properties.length) {
      return this._jsonExampleFromProperties(properties);
    }
  }

  _computeJsonArrayValue(range) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
    const items = this._ensureArray(range[key]);
    if (!items) {
      return;
    }
    const result = [];
    for (let i = 0, len = items.length; i < len; i++) {
      let item = items[i];
      if (item instanceof Array) {
        item = item[0];
      }
      const value = this._computeJsonProperyValue(item);
      if (value !== undefined) {
        result[result.length] = value;
      }
    }
    return result;
  }
  /**
   * Gets a value from a Range shape for a scalar value.
   * @param {Object} range AMF's range model.
   * @return {any}
   */
  _getTypeScalarValue(range) {
    const dvKey = this._getAmfKey(this.ns.w3.shacl.name + 'defaultValue');
    let dv = range[dvKey];
    if (dv) {
      if (dv instanceof Array) {
        dv = dv[0];
      }
      return this._getValue(dv, this.ns.raml.vocabularies.data + 'value');
    }
    const rKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
    let ex = range[rKey];
    if (ex) {
      if (ex instanceof Array) {
        ex = ex[0];
      }
      return this._getValue(ex, this.ns.w3.shacl.name + 'raw');
    }
  }
  /**
   * Computes example from RAML type for XML media type.
   * @param {Array<Object>} properties
   * @param {?String} typeName RAML type name
   * @return {String}
   */
  _xmlExampleFromProperties(properties, typeName) {
    const doc = document.implementation.createDocument('', '', null);
    const main = doc.createElement(typeName);
    doc.appendChild(main);
    const nl = doc.createTextNode('\n');
    main.appendChild(nl);
    for (let i = 0, len = properties.length; i < len; i++) {
      this._xmlProcessProperty(doc, main, properties[i]);
    }
    const s = new XMLSerializer();
    return s.serializeToString(doc);
  }
  /**
   * Processes an XML property
   * @param {Document} doc Main document
   * @param {Element} node Current node
   * @param {Object} property AMF property
   */
  _xmlProcessProperty(doc, node, property) {
    if (!property) {
      return;
    }
    if (this._hasType(property, this.ns.w3.shacl.name + 'NodeShape')) {
      const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
      const properties = this._ensureArray(property[pKey]);
      if (!properties) {
        return;
      }
      for (let i = 0, len = properties.length; i < len; i++) {
        this._xmlProcessProperty(doc, node, properties[i]);
      }
      return;
    }
    const rKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'range');
    let range = property[rKey];
    if (!range) {
      return;
    }
    if (range instanceof Array) {
      range = range[0];
    }
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'xmlSerialization');
    let serialization = range[sKey];
    let isWrapped = false;
    if (serialization) {
      if (serialization instanceof Array) {
        serialization = serialization[0];
      }
      const isAtribute = this._getValue(serialization, this.ns.raml.vocabularies.shapes + 'xmlAttribute');
      if (isAtribute) {
        this._appendXmlAttribute(node, property, range, serialization);
        return;
      }
      isWrapped = this._getValue(serialization, this.ns.raml.vocabularies.shapes + 'xmlWrapped');
    }
    if (this._hasType(range, this.ns.w3.shacl.name + 'NodeShape')) {
      this._appendXmlElements(doc, node, property, range);
      return;
    }
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      this._appendXmlArray(doc, node, property, range, isWrapped);
      return;
    }
    this._appendXmlElement(doc, node, property, range);
  }
  /**
   * Reads property data type.
   * @param {Object} shape
   * @return {String} Data type
   */
  _readDataType(shape) {
    const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
    let dataType = shape[dtKey];
    if (!dataType) {
      return;
    }
    if (dataType instanceof Array) {
      dataType = dataType[0];
    }
    dataType = dataType['@id'];
    const vKey = this._getAmfKey(this.ns.w3.xmlSchema);
    let result = dataType.replace(vKey, '');
    if (result[0] === ':') {
      result = result.substr(1);
    }
    return result;
  }
  /**
   * Appends an attribute to the node from AMF property
   * @param {Element} node Current node
   * @param {Object} property AMF property
   * @param {Object} range AMF range
   * @param {Object} serialization Serialization info
   */
  _appendXmlAttribute(node, property, range, serialization) {
    let name = this._getValue(serialization, this.ns.raml.vocabularies.shapes + 'xmlName');
    if (!name) {
      name = this._getValue(range, this.ns.w3.shacl.name + 'name');
    }
    if (!name) {
      return;
    }
    if (name.indexOf('?') !== -1) {
      name = name.replace('?', '');
    }
    let value = this._readDataType(range);
    if (!value) {
      value = '';
    }
    node.setAttribute(name, value);
  }
  /**
   * Appends an element to the node tree from a type
   * @param {Document} doc Main document
   * @param {Element} node Current node
   * @param {Object} property AMF property
   * @param {Object} range AMF range
   * @return {Element} Newly created element
   */
  _appendXmlElement(doc, node, property, range) {
    const name = this._getValue(range, this.ns.w3.shacl.name + 'name');
    if (!name) {
      return;
    }
    let nodeValue = this._getValue(range, this.ns.w3.shacl.name + 'defaultValueStr');
    if (!nodeValue) {
      const eKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
      let example = range[eKey];
      if (example) {
        if (example instanceof Array) {
          example = example[0];
        }
        nodeValue = this._getValue(example, this.ns.w3.shacl.name + 'raw');
      }
    }
    if (!nodeValue) {
      nodeValue = this._readDataType(range);
    }
    const element = doc.createElement(name);
    if (nodeValue) {
      const vn = doc.createTextNode(nodeValue);
      element.appendChild(vn);
    }
    node.appendChild(element);
    const nl = doc.createTextNode('\n');
    node.appendChild(nl);
    return element;
  }

  _appendXmlElements(doc, node, property, range) {
    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    const properties = this._ensureArray(range[pKey]);
    const element = this._appendXmlElement(doc, node, property, range);
    if (!properties) {
      return;
    }
    const nl = doc.createTextNode('\n');
    element.appendChild(nl);
    for (let i = 0, len = properties.length; i < len; i++) {
      this._xmlProcessProperty(doc, element, properties[i]);
    }
  }

  _appendXmlArray(doc, node, property, range, isWrapped) {
    if (isWrapped) {
      const element = this._appendXmlElement(doc, node, property, range);
      node.appendChild(element);
      const nl = doc.createTextNode('\n');
      node.appendChild(nl);
      node = element;
    }
    const pKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
    const properties = this._ensureArray(range[pKey]);
    if (!properties) {
      return;
    }
    const nl = doc.createTextNode('\n');
    node.appendChild(nl);
    for (let i = 0, len = properties.length; i < len; i++) {
      this._xmlProcessProperty(doc, node, properties[i]);
    }
  }
}
window.customElements.define(ApiExampleGenerator.is, ApiExampleGenerator);
</script>
