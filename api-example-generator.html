<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../amf-helper-mixin/amf-helper-mixin.html">
<script>
/**
 * `api-example-generator`
 *
 * Examples generator from AMF model
 *
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin ApiElements.AmfHelperMixin
 */
class ApiExampleGenerator extends ApiElements.AmfHelperMixin(Polymer.Element) {
  /**
   * @type {String}
   */
  static get is() {
    return 'api-example-generator';
  }
  /**
   * @type {Object}
   */
  static get properties() {
    return {
      /**
       * AMF `http://a.ml/vocabularies/http#Payload` shape type.
       * Note, you must set `amfModel` property to resolve references in
       * the model.
       * @type {Object}
       */
      shape: Object,
      example: {
        type: String,
        readOnly: true,
        notify: true
      },
      auto: Boolean
    };
  }
  /**
   * @type {Array}
   */
  static get observers() {
    return [
      '_shapeAutoChanged(shape, auto)'
    ];
  }
  /**
   * Generates example when shape changes when `auto` is set to true.
   *
   * @param {Array|Object} shape
   * @param {?Boolean} auto
   */
  _shapeAutoChanged(shape, auto) {
    if (!auto) {
      return;
    }
    if (!shape) {
      this._setExample(undefined);
      return;
    }
    const example = this.generate(shape);
    this._setExample(example);
  }

  /**
   * Generates the example from a shape.
   * @param {?Array|Object} shape AMF shape definition
   * @return {String|undefined} Example value.
   */
  generate(shape) {
    if (!shape) {
      shape = this.shape;
    }
    if (!shape) {
      return;
    }
    if (shape instanceof Array) {
      shape = shape[0];
    }
    shape = this._resolve(shape);
    const mediaType = this._getValue(shape,
      this.ns.raml.vocabularies.http + 'mediaType');
    if (!mediaType) {
      return;
    }
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.http + 'schema');
    let schema = shape[sKey];
    if (!schema) {
      return;
    }
    if (schema instanceof Array) {
      schema = schema[0];
    }
    return this.computeExample(mediaType, schema);
  }
  /**
   * Computes an example for given media type.
   * @param {String} type Media type
   * @param {Object} schema Payload's schema
   * @return {String|undefined}
   */
  computeExample(type, schema) {
    if (this._hasType(schema,
      this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      const iKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
      const items = this._ensureArray(schema[iKey]);
      // We need only first type here as arras can have different types
      for (let i = 0, len = items.length; i < len; i++) {
        const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
        const properties = this._ensureArray(items[i][pKey]);
        const typeName = this._getValue(items[i], this.ns.w3.shacl.name + 'name');
        const _example = this._exampleFromProperties(type, properties, typeName);
        if (_example) {
          return '[' + _example + ']';
        }
      }
      return;
    }
    const eKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
    const examples = this._ensureArray(schema[eKey]);
    if (!examples || !examples.length) {
      const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
      const properties = this._ensureArray(schema[pKey]);
      if (properties && properties.length) {
        const typeName = this._getValue(schema, this.ns.w3.shacl.name + 'name');
        return this._exampleFromProperties(type, properties, typeName);
      }
      return;
    }
    return this._exampleFromExamples(type, examples);
  }
  /**
   * Searches for an example in examples array by it's media type.
   * @param {String} type Payload's media type
   * @param {Array<Object>} examples List of examples
   * @return {Object|undefined} Example's model or undefined if not found.
   */
  _exampleFromMediaType(type, examples) {
    let example;
    for (let i = 0; i < examples.length; i++) {
      const _tmp = examples[i];
      const _type = this._getValue(_tmp,
        this.ns.raml.vocabularies.http + 'mediaType');
      if (type !== _type) {
        continue;
      }
      example = _tmp;
      break;
    }
    return example;
  }
  /**
   * Generate an example from the examples array.
   *
   * @param {String} type Bosy content type.
   * @param {Array<Object>} examples Resolved examples.
   * @return {String|undefined}
   */
  _exampleFromExamples(type, examples) {
    const example = examples.length === 1 ? examples[0] :
      this._exampleFromMediaType(type, examples);
    if (!example) {
      return;
    }
    const raw = this._getValue(example,
      this.ns.raml.vocabularies.document + 'raw');
    if (raw) {
      if (type.indexOf('json') === -1) {
        return raw;
      }
      try {
        JSON.parse(raw);
        return raw;
      } catch (_) {}
    }
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'structuredValue');
    let structure = example[sKey];
    if (!structure) {
      return;
    }
    if (structure instanceof Array) {
      structure = structure[0];
    }
    const result = this._jsonFromStructure(structure);
    if (result) {
      if (typeof result === 'object') {
        return JSON.stringify(result, null, 2);
      }
    }
  }
  /**
   * Creates a JSON example representation from AMF example's structure
   * definition.
   * @param {Object} structure
   * @return {any}
   */
  _jsonFromStructure(structure) {
    if (!structure) {
      return;
    }
    const prefix = this.ns.raml.vocabularies.data;
    if (this._hasType(structure, prefix + 'Scalar')) {
      return this._getValue(structure, prefix + 'value');
    }
    let obj;
    if (this._hasType(structure, prefix + 'Object')) {
      obj = {};
    } else if (this._hasType(structure, prefix + 'Array')) {
      obj = [];
    } else {
      return;
    }

    const isArray = obj instanceof Array;
    const resolvedPrefix = this._getAmfKey(prefix);
    Object.keys(structure).forEach((key) => {
      if (key.indexOf(resolvedPrefix) !== 0) {
        return;
      }
      let v = structure[key];
      if (v instanceof Array) {
        v = v[0];
      }
      const value = this._jsonFromStructure(v);
      if (!value) {
        return;
      }
      if (isArray) {
        obj[obj.length] = value;
      } else {
        key = key.replace(resolvedPrefix, '');
        if (key[0] === ':') {
          key = key.substr(1);
        }
        obj[key] = value;
      }
    });
    return obj;
  }
  /**
   * Creates an example from RAML type properties.
   * @param {String} type Media type
   * @param {Array} properties
   * @param {?String} typeName Name of the RAML type.
   * @return {any}
   */
  _exampleFromProperties(type, properties, typeName) {
    if (type.indexOf('json') !== -1) {
      const value = this._jsonExampleFromProperties(properties);
      if (value) {
        return JSON.stringify(value, null, 2);
      }
      return;
    }
    if (type.indexOf('xml') !== -1) {
      return this._xmlExampleFromProperties(properties, typeName);
    }
  }
  /**
   * Generates a JSON example from RAML's type properties.
   * @param {Array} properties List of type properties
   * @return {String|undefined}
   */
  _jsonExampleFromProperties(properties) {
    const result = {};
    for (let i = 0, len = properties.length; i < len; i++) {
      const property = properties[i];
      const name = this._getValue(property, this.ns.w3.shacl.name + 'name');
      if (!name) {
        continue;
      }
      const rKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'range');
      let range = property[rKey];
      if (!range) {
        continue;
      }
      if (range instanceof Array) {
        range = range[0];
      }
      const value = this._computeJsonProperyValue(range);
      result[name] = value || '';
    }
    return result;
  }
  /**
   * Computes JSON value from a range shape.
   * @param {Object} range AMF's range model.
   * @return {any}
   */
  _computeJsonProperyValue(range) {

    if (this._hasType(range,
      this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
      let value = this._getTypeScalarValue(range);
      let prefix = this._getAmfKey(this.ns.w3.xmlSchema);
      if (prefix !== this.ns.w3.xmlSchema) {
        prefix += ':';
      }
      const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
      let dt = range[dtKey];
      if (!dt) {
        return value || '';
      }
      if (dt instanceof Array) {
        dt = dt[0];
      }

      switch (dt['@id']) {
        case prefix + 'boolean':
          if (value !== undefined) {
            return value === 'true' ? true : false;
          }
          return value;
        case prefix + 'integer':
        case prefix + 'number':
          if (value) {
            if (isNaN(value)) {
              return 0;
            }
            return Number(value);
          }
          return 0;
        default: return value || '';
      }
    }
    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'UnionShape')) {
      const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
      const list = this._ensureArray(range[key]);
      if (!list) {
        return;
      }
      for (let i = 0, len = list.length; i < len; i++) {
        const item = list[i];
        if (this._hasType(item, this.ns.w3.shacl.name + 'NodeShape')) {
          const data = this._ensureArray(item[pKey]);
          if (data) {
            return this._jsonExampleFromProperties(data);
          }
        }
      }
      return;
    }
    if (this._hasType(range, this.ns.w3.shacl.name + 'NodeShape')) {
      const properties = this._ensureArray(range[pKey]);
      if (properties && properties.length) {
        return this._jsonExampleFromProperties(properties);
      }
      return;
    }
  }
  /**
   * Gets a value from a Range shape for a scalar value.
   * @param {Object} range AMF's range model.
   * @return {any}
   */
  _getTypeScalarValue(range) {
    const dvKey = this._getAmfKey(this.ns.w3.shacl.name + 'defaultValue');
    let dv = range[dvKey];
    if (dv) {
      if (dv instanceof Array) {
        dv = dv[0];
      }
      return this._getValue(dv, this.ns.raml.vocabularies.data + 'value');
    }
    const rKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
    let ex = range[rKey];
    if (ex) {
      if (ex instanceof Array) {
        ex = ex[0];
      }
      return this._getValue(ex, this.ns.w3.shacl.name + 'raw');
    }
    const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
    let type = range[dtKey];
    if (!type) {
      return;
    }
    if (type instanceof Array) {
      type = type[0];
    }
    const typeDef = type['@id'];
    let scKey = this._getAmfKey(this.ns.w3.xmlSchema);
    let shKey = this._getAmfKey(this.ns.raml.vocabularies.shapes);
    if (scKey !== this.ns.w3.xmlSchema) {
      scKey += ':';
    }
    if (shKey !== this.ns.raml.vocabularies.shapes) {
      shKey += ':';
    }
    return typeDef
    .replace(scKey, '')
    .replace(shKey, '');
  }
  /**
   * Computes example from RAML type for XML media type.
   * @param {Array<Object>} properties
   * @param {?String} typeName RAML type name
   * @return {String}
   */
  _xmlExampleFromProperties(properties, typeName) {
    console.warn('Implement me.');
    return;
  }
}
window.customElements.define(ApiExampleGenerator.is, ApiExampleGenerator);
</script>
